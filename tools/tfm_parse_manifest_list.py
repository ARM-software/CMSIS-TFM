#-------------------------------------------------------------------------------
# Copyright (c) 2018-2019, Arm Limited. All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause
#
#-------------------------------------------------------------------------------

import os
import io
import sys
import argparse
from jinja2 import Environment, BaseLoader, select_autoescape

try:
    import yaml
except ImportError as e:
    print (str(e) + " To install it, type:")
    print ("pip install PyYAML")
    exit(1)

donotedit_warning = \
                    "/*********** " + \
                    "WARNING: This is an auto-generated file. Do not edit!" + \
                    " ***********/"
manifest_list_yaml_file_path = os.path.join('tools', 'tfm_manifest_list.yaml')

class TemplateLoader(BaseLoader):
    """
    Template loader class.

    An instance of this class is passed to the template engine. It is
    responsible for reading the template file
    """
    def __init__(self):
        pass

    def get_source(self, environment, template):
        """
        This function reads the template files.
        For detailed documentation see:
        http://jinja.pocoo.org/docs/2.10/api/#jinja2.BaseLoader.get_source

        Please note that this function always return 'false' as 'uptodate'
        value, so the output file will always be generated.
        """
        if not os.path.isfile(template):
            raise TemplateNotFound(template)
        with open(template) as f:
            source = f.read()
        return source, template, False

def load_manifest_list(file):
    """
    Load the substitution data from the manifests.

    Parameters
    ----------
    file : file
        A yaml file containing the manifest list

    Returns
    -------
    list
        The list of the contents of the manifest files, as generated by the yaml
        parser.
        """
    db = []
    manifest_list = yaml.safe_load(file)
    for item in manifest_list["manifest_list"]:
        manifest_path = os.path.expandvars(item['manifest'])
        try:
            file = open(manifest_path)
            manifest = yaml.safe_load(file)
            db.append({"manifest": manifest, "attr": item})
        except IOError:
            raise Exception ("Manifest for "+item['name']+" cannot be opened at path "+item['manifest'])

    return db

def generate_manifestfilename(env, out_dir):
    """
    Generate manifestfilename header file.

    Parameters
    ----------
    env :
        The instance of Environment.
    out_dir:
        The root directory that files are generated to.
    """

    manifest_header_list = []
    with open(manifest_list_yaml_file_path) as manifest_list_yaml_file:
        manifest_list = yaml.safe_load(manifest_list_yaml_file)
        templatefile_name = 'secure_fw/services/manifestfilename.template'
        template = env.get_template(templatefile_name)

        for manifest_file in manifest_list["manifest_list"]:
            manifest_path = os.path.expandvars(manifest_file['manifest'])
            file = open(manifest_path)
            manifest = yaml.safe_load(file)

            utilities = {}
            utilities['donotedit_warning']=donotedit_warning

            context = {}
            context['manifest'] = manifest
            context['attr'] = manifest_file
            context['utilities'] = utilities

            manifest_dir, manifest_name = os.path.split(manifest_path)
            outfile_name = manifest_name.replace('yaml', 'h').replace('json', 'h')
            context['file_name'] = outfile_name.replace('.h', '')
            outfile_name = os.path.join(manifest_dir, "psa_manifest", outfile_name)

            manifest_header_list.append(outfile_name)

            if out_dir is not None:
                outfile_name = os.path.join(out_dir, outfile_name)

            outfile_path = os.path.dirname(outfile_name)
            if not os.path.exists(outfile_path):
                os.makedirs(outfile_path)

            print ("Generating " + outfile_name)

            outfile = io.open(outfile_name, "w", newline='\n')
            outfile.write(template.render(context))
            outfile.close()
    return manifest_header_list

def main():
    """
    The entry point of the script.

    Generates the output files based on the templates and the manifests.
    """

    parser = argparse.ArgumentParser(description='Parse secure partition manifest list and generate files listed by the file list')
    parser.add_argument('-o', '--outdir'
                        , dest='outdir'
                        , required=False
                        , default=None
                        , metavar='out_dir'
                        , help='The root directory for generated files, the default is TF-M base folder.')

    args = parser.parse_args()

    out_dir = args.outdir

    # Arguments could be relative path.
    # Convert to absolute path as we are going to change directory later
    if out_dir is not None:
        out_dir = os.path.abspath(out_dir)
    """
    Relative path to TF-M base folder is supported in the manifests
    and default value of manifest list and generated file list are relative to TF-M base folder as well,
    so first change directory to TF-M base folder.
    By doing this, the script can be executed anywhere
    The script is located in <TF-M base folder>/tools, so sys.path[0]<location of the script>/.. is TF-M base folder.
    """
    os.chdir(os.path.join(sys.path[0], ".."))

    env = Environment(
        loader = TemplateLoader(),
        autoescape = select_autoescape(['html', 'xml']),
        lstrip_blocks = True,
        trim_blocks = True,
        keep_trailing_newline = True
    )

    # Generate manifestfilename
    manifest_header_list = generate_manifestfilename(env, out_dir)
    utilities = {}
    context = {}

    with open(manifest_list_yaml_file_path) as manifest_list_yaml_file:
        # Read manifest list file, build database
        db = load_manifest_list(manifest_list_yaml_file)

        utilities['donotedit_warning']=donotedit_warning
        utilities['manifest_header_list']=manifest_header_list

        context['manifests'] = db
        context['utilities'] = utilities

    with open(os.path.join('tools', 'tfm_generated_file_list.yaml')) \
                                                    as file_list_yaml_file:
        # read list of files that need to be generated from templates using db
        file_list_yaml = yaml.safe_load(file_list_yaml_file)
        file_list = file_list_yaml["file_list"]
        for file in file_list:
            outfile_name = os.path.expandvars(file["output"])
            templatefile_name = outfile_name + '.template'

            if out_dir is not None:
                outfile_name = os.path.join(out_dir, outfile_name)

            outfile_path = os.path.dirname(outfile_name)
            if not os.path.exists(outfile_path):
                os.makedirs(outfile_path)

            print ("Generating " + outfile_name)

            template = env.get_template(templatefile_name)

            outfile = io.open(outfile_name, "w", newline='\n')
            outfile.write(template.render(context))
            outfile.close()

    print ("Generation of files done")

if __name__ == "__main__":
    main()
